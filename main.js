/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MentionTaskRouter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var MentionTaskRouter = class extends import_obsidian.Plugin {
  async onload() {
    console.log("MentionTaskRouter loaded");
    this.registerDomEvent(document, "keydown", (evt) => {
      if (evt.key === "Enter") {
        console.log("Enter key detected via DOM event");
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (!view) {
          console.log("No active markdown view");
          return;
        }
        const editor = view.editor;
        if (!editor) {
          console.log("No editor");
          return;
        }
        const cursor = editor.getCursor();
        const currentLine = editor.getLine(cursor.line);
        console.log("Current line:", currentLine);
        setTimeout(async () => {
          const newCursor = editor.getCursor();
          const lineNum = newCursor.line - 1;
          const previousLine = lineNum >= 0 ? editor.getLine(lineNum) : "";
          console.log("Previous line after Enter:", previousLine);
          const result = await this.processLine(previousLine.trim());
          if (result && result.mentions.length > 0 && lineNum >= 0) {
            let linkedText = previousLine;
            const mentionRE = /(?<!\S)@([^\s@/]+)/gu;
            linkedText = linkedText.replace(mentionRE, (match2, mention) => {
              return `@[[${mention}]]`;
            });
            let processedText = linkedText;
            const wordRE = /(?<!\S)[^\s\r\n]+(?!\S)/g;
            let match;
            let offset = 0;
            while ((match = wordRE.exec(linkedText)) !== null) {
              const word = match[0];
              const startPos = match.index + offset;
              const beforeText = processedText.substring(0, startPos);
              const openBrackets = (beforeText.match(/\[\[/g) || []).length;
              const closeBrackets = (beforeText.match(/\]\]/g) || []).length;
              const inLink = openBrackets > closeBrackets;
              if (inLink) {
                continue;
              }
              const emailContext = linkedText.substring(Math.max(0, match.index - 20), match.index + word.length + 20);
              if (emailContext.match(/[^\s\r\n]+@[^\s\r\n]+\.[^\s\r\n]+/)) {
                continue;
              }
              const firstMention = result.mentions[0];
              const sanitizedWord = this.sanitizeFilename(word);
              if (!sanitizedWord || sanitizedWord === "untitled") {
                continue;
              }
              const replacement = `[[${firstMention}/${sanitizedWord}]]`;
              processedText = processedText.substring(0, startPos) + replacement + processedText.substring(startPos + word.length);
              offset += replacement.length - word.length;
            }
            linkedText = processedText;
            editor.setLine(lineNum, linkedText);
            console.log("Replaced line with links:", linkedText);
          }
        }, 50);
      }
    });
  }
  /** ファイル名として使用可能な文字列にサニタイズ */
  sanitizeFilename(text) {
    if (!text)
      return "";
    let sanitized = text.replace(/[<>:"|?*\\/\x00-\x1f]/g, "").replace(/^[.\s]+|[.\s]+$/g, "").trim();
    if (!sanitized) {
      return "untitled";
    }
    if (sanitized.length > 200) {
      sanitized = sanitized.substring(0, 200);
    }
    return sanitized;
  }
  /** 行を解析して該当ファイルに追記 */
  async processLine(raw) {
    console.log("processLine called with:", raw);
    const mentionRE = /(?<!\S)@([^\s@/]+)/gu;
    const mentions = [...raw.matchAll(mentionRE)].map((m) => m[1]);
    console.log("Found mentions:", mentions);
    if (!mentions.length) {
      console.log("No mentions found");
      return null;
    }
    const activeFile = this.app.workspace.getActiveFile();
    const currentFileName = activeFile ? activeFile.basename : "Unknown";
    const rawBody = raw.replace(mentionRE, "").trim() || mentions.join(" ");
    const body = this.sanitizeFilename(rawBody);
    const now = /* @__PURE__ */ new Date();
    const dateStr = now.getFullYear() + "-" + String(now.getMonth() + 1).padStart(2, "0") + "-" + String(now.getDate()).padStart(2, "0");
    const timeStr = now.getHours() + ":" + String(now.getMinutes()).padStart(2, "0");
    const datetime = `${dateStr} ${timeStr}`;
    const taskLine = `- [ ] [[tasks/${mentions[0]}-${body}]], added: ${datetime}, from [[${currentFileName}]]`;
    console.log("Task line:", taskLine);
    try {
      await Promise.all(
        mentions.map(async (m) => {
          const path = `${m}.md`;
          console.log("Attempting to write to:", path);
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof import_obsidian.TFile) {
            console.log("Appending to existing file:", path);
            await this.app.vault.append(file, "\n" + taskLine);
            console.log("Successfully appended to:", path);
          } else {
            console.log("Creating new file:", path);
            const newFile = await this.app.vault.create(path, "# Tasks\n\n" + taskLine);
            console.log("Successfully created file:", path, newFile);
          }
        })
      );
      await Promise.all(
        mentions.map(async (mention) => {
          const taskContentPath = `tasks/${mention}-${body}.md`;
          const tasksFolder = this.app.vault.getAbstractFileByPath("tasks");
          if (!tasksFolder) {
            await this.app.vault.createFolder("tasks");
          }
          const taskContentFile = this.app.vault.getAbstractFileByPath(taskContentPath);
          if (!(taskContentFile instanceof import_obsidian.TFile)) {
            console.log("Creating task content file:", taskContentPath);
            await this.app.vault.create(taskContentPath, `# ${body}

`);
          }
          const mentionPath = `${mention}.md`;
          const mentionFile = this.app.vault.getAbstractFileByPath(mentionPath);
          const linkLine = `- [[${taskContentPath.replace(".md", "")}]]`;
          if (mentionFile instanceof import_obsidian.TFile) {
            const existingContent = await this.app.vault.read(mentionFile);
            if (!existingContent.includes(`[[${taskContentPath.replace(".md", "")}]]`)) {
              await this.app.vault.append(mentionFile, "\n" + linkLine);
              console.log(`Added link to ${body} in ${mention}.md`);
            }
          } else {
            console.log("Creating mention file with link:", mentionPath);
            await this.app.vault.create(mentionPath, `# ${mention}

${linkLine}`);
          }
        })
      );
      console.log("Task routing completed successfully");
    } catch (error) {
      console.error("Error in task routing:", error);
    }
    return { mentions };
  }
  onunload() {
    console.log("MentionTaskRouter unloaded");
  }
};
